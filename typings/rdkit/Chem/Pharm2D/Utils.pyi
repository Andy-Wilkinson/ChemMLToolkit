"""
This type stub file was generated by pyright.
"""

""" utility functionality for the 2D pharmacophores code

  See Docs/Chem/Pharm2D.triangles.jpg for an illustration of the way
  pharmacophores are broken into triangles and labelled.

  See Docs/Chem/Pharm2D.signatures.jpg for an illustration of bit
  numbering

"""
nPointDistDict = ...
nDistPointDict = ...
_trianglesInPharmacophore = ...
def GetTriangles(nPts): # -> tuple[Any, ...] | list[Unknown]:
    """ returns a tuple with the distance indices for
     triangles composing an nPts-pharmacophore

    """
    ...

def BinsTriangleInequality(d1, d2, d3): # -> bool:
    """ checks the triangle inequality for combinations
      of distance bins.

      the general triangle inequality is:
         d1 + d2 >= d3
      the conservative binned form of this is:
         d1(upper) + d2(upper) >= d3(lower)

    """
    ...

def ScaffoldPasses(combo, bins=...): # -> bool:
    """ checks the scaffold passed in to see if all
    contributing triangles can satisfy the triangle inequality

    the scaffold itself (encoded in combo) is a list of binned distances

    """
    ...

_numCombDict = ...
def NumCombinations(nItems, nSlots): # -> int:
    """  returns the number of ways to fit nItems into nSlots

      We assume that (x,y) and (y,x) are equivalent, and
      (x,x) is allowed.

      General formula is, for N items and S slots:
        res = (N+S-1)! / ( (N-1)! * S! )

    """
    ...

_verbose = ...
_countCache = ...
def CountUpTo(nItems, nSlots, vs, idx=..., startAt=...): # -> Literal[0]:
    """ Figures out where a given combination of indices would
     occur in the combinatorial explosion generated by _GetIndexCombinations_

     **Arguments**

       - nItems: the number of items to distribute

       - nSlots: the number of slots in which to distribute them

       - vs: a sequence containing the values to find

       - idx: used in the recursion

       - startAt: used in the recursion

    **Returns**

       an integer

    """
    ...

_indexCombinations = ...
def GetIndexCombinations(nItems, nSlots, slot=..., lastItemVal=...): # -> list[list[int]]:
    """ Generates all combinations of nItems in nSlots without including
      duplicates

    **Arguments**

      - nItems: the number of items to distribute

      - nSlots: the number of slots in which to distribute them

      - slot: used in recursion

      - lastItemVal: used in recursion

    **Returns**

      a list of lists

    """
    ...

def GetAllCombinations(choices, noDups=..., which=...): # -> list[list[Unknown]]:
    """  Does the combinatorial explosion of the possible combinations
    of the elements of _choices_.

    **Arguments**

      - choices: sequence of sequences with the elements to be enumerated

      - noDups: (optional) if this is nonzero, results with duplicates,
        e.g. (1,1,0), will not be generated

      - which: used in recursion

    **Returns**

      a list of lists

    >>> GetAllCombinations([(0,),(1,),(2,)])
    [[0, 1, 2]]
    >>> GetAllCombinations([(0,),(1,3),(2,)])
    [[0, 1, 2], [0, 3, 2]]

    >>> GetAllCombinations([(0,1),(1,3),(2,)])
    [[0, 1, 2], [0, 3, 2], [1, 3, 2]]

    """
    ...

def GetUniqueCombinations(choices, classes, which=...): # -> list[list[tuple[Unknown, Unknown]]]:
    """  Does the combinatorial explosion of the possible combinations
    of the elements of _choices_.

    """
    ...

def GetUniqueCombinations_new(choices, classes, which=...): # -> list[list[Unknown]]:
    """  Does the combinatorial explosion of the possible combinations
    of the elements of _choices_.

    """
    ...

def UniquifyCombinations(combos): # -> list[Unknown]:
    """ uniquifies the combinations in the argument

      **Arguments**:

        - combos: a sequence of sequences

      **Returns**

        - a list of tuples containing the unique combos

    """
    ...

def GetPossibleScaffolds(nPts, bins, useTriangleInequality=...): # -> list[tuple[int]] | Literal[0]:
    """ gets all realizable scaffolds (passing the triangle inequality) with the
       given number of points and returns them as a list of tuples

    """
    ...

def OrderTriangle(featIndices, dists): # -> tuple[Unknown, Unknown] | tuple[list[Unknown], list[Unknown]]:
    """
      put the distances for a triangle into canonical order

      It's easy if the features are all different:

      >>> OrderTriangle([0,2,4],[1,2,3])
      ([0, 2, 4], [1, 2, 3])

      It's trickiest if they are all the same:
      
      >>> OrderTriangle([0,0,0],[1,2,3])
      ([0, 0, 0], [3, 2, 1])
      >>> OrderTriangle([0,0,0],[2,1,3])
      ([0, 0, 0], [3, 2, 1])
      >>> OrderTriangle([0,0,0],[1,3,2])
      ([0, 0, 0], [3, 2, 1])
      >>> OrderTriangle([0,0,0],[3,1,2])
      ([0, 0, 0], [3, 2, 1])
      >>> OrderTriangle([0,0,0],[3,2,1])
      ([0, 0, 0], [3, 2, 1])

      >>> OrderTriangle([0,0,1],[3,2,1])
      ([0, 0, 1], [3, 2, 1])
      >>> OrderTriangle([0,0,1],[1,3,2])
      ([0, 0, 1], [1, 3, 2])
      >>> OrderTriangle([0,0,1],[1,2,3])
      ([0, 0, 1], [1, 3, 2])
      >>> OrderTriangle([0,0,1],[1,3,2])
      ([0, 0, 1], [1, 3, 2])

    """
    ...

if __name__ == '__main__':
    ...
