"""
This type stub file was generated by pyright.
"""

from types import *

"""
PDFgen is a library to generate PDF files containing text and graphics.  It is the
foundation for a complete reporting solution in Python.  It is also the
foundation for piddlePDF, the PDF back end for PIDDLE.

Documentation is a little slim right now; run then look at testpdfgen.py
to get a clue.

---------- Licence Terms (same as the Python license) -----------------
(C) Copyright Robinson Analytics 1998-1999.

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation, and that the name of Robinson Analytics not be used
in advertising or publicity pertaining to distribution of the software
without specific, written prior permission.

ROBINSON ANALYTICS LTD. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
IN NO EVENT SHALL ROBINSON ANALYTICS BE LIABLE FOR ANY SPECIAL, INDIRECT
OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.

Progress Reports:
0.82, 1999-10-27, AR:
        Fixed some bugs on printing to Postscript.  Added 'Text Object'
        analogous to Path Object to control entry and exit from text mode.
        Much simpler clipping API.  All verified to export Postscript and
        redistill.
        One limitation still - clipping to text paths is fine in Acrobat
        but not in Postscript (any level)

0.81,1999-10-13, AR:
        Adding RoundRect; changed all format strings to use %0.2f instead of %s,
        so we don't get exponentials in the output.
0.8,1999-10-07, AR:  all changed!

2000-02-07: changed all %0.2f's to %0.4f in order to allow precise ploting of graphs that
        range between 0 and 1 -cwl

"""
class PDFError(ValueError):
  ...


FILL_EVEN_ODD = ...
FILL_NON_ZERO = ...
PATH_OPS = ...
close = ...
newpath = ...
stroke = ...
closeStroke = ...
nzFill = ...
eoFill = ...
fillStroke = ...
closeFillStroke = ...
eoFillStroke = ...
closeEoFillStroke = ...
class Canvas:
  """This is a low-level interface to the PDF file format.  The plan is to
    expose the whole pdfgen API through this.  Its drawing functions should have a
    one-to-one correspondence with PDF functionality.  Unlike PIDDLE, it thinks
    in terms of RGB values, Postscript font names, paths, and a 'current graphics
    state'.  Just started development at 5/9/99, not in use yet.

    """
  def __init__(self, filename, pagesize=..., bottomup=...) -> None:
    """Most of the attributes are private - we will use set/get methods
        as the preferred interface.  Default page size is A4."""
    ...
  
  def setAuthor(self, author): # -> None:
    ...
  
  def setTitle(self, title): # -> None:
    ...
  
  def setSubject(self, subject): # -> None:
    ...
  
  def pageHasData(self): # -> bool:
    "Info function - app can call it after showPage to see if it needs a save"
    ...
  
  def showPage(self): # -> None:
    """This is where the fun happens"""
    ...
  
  def getPageNumber(self): # -> int:
    ...
  
  def save(self, filename=..., fileobj=...): # -> None:
    """Saves the pdf document to fileobj or to file with name filename.
        If holding data, do a showPage() to save them having to."""
    ...
  
  def setPageSize(self, size): # -> None:
    """accepts a 2-tuple in points for paper size for this
        and subsequent pages"""
    ...
  
  def addLiteral(self, s, escaped=...): # -> None:
    ...
  
  def transform(self, a, b, c, d, e, f): # -> None:
    """How can Python track this?"""
    ...
  
  def translate(self, dx, dy): # -> None:
    ...
  
  def scale(self, x, y): # -> None:
    ...
  
  def rotate(self, theta): # -> None:
    """Canvas.rotate(theta)

        theta is in degrees."""
    ...
  
  def skew(self, alpha, beta): # -> None:
    ...
  
  def saveState(self): # -> None:
    """These need expanding to save/restore Python's state tracking too"""
    ...
  
  def restoreState(self): # -> None:
    """These need expanding to save/restore Python's state tracking too"""
    ...
  
  def line(self, x1, y1, x2, y2): # -> None:
    "As it says"
    ...
  
  def lines(self, linelist): # -> None:
    """As line(), but slightly more efficient for lots of them -
        one stroke operation and one less function call"""
    ...
  
  def grid(self, xlist, ylist): # -> None:
    """Lays out a grid in current line style.  Suuply list of
        x an y positions."""
    ...
  
  def bezier(self, x1, y1, x2, y2, x3, y3, x4, y4): # -> None:
    "Bezier curve with the four given control points"
    ...
  
  def arc(self, x1, y1, x2, y2, startAng=..., extent=...): # -> None:
    """Contributed to piddlePDF by Robert Kern, 28/7/99.
        Trimmed down by AR to remove color stuff for pdfgen.canvas and
        revert to positive coordinates.

        Draw a partial ellipse inscribed within the rectangle x1,y1,x2,y2,
        starting at startAng degrees and covering extent degrees.   Angles
        start with 0 to the right (+x) and increase counter-clockwise.
        These should have x1<x2 and y1<y2.

        The algorithm is an elliptical generalization of the formulae in
        Jim Fitzsimmon's TeX tutorial <URL: http://www.tinaja.com/bezarc1.pdf>."""
    ...
  
  def rect(self, x, y, width, height, stroke=..., fill=...): # -> None:
    "draws a rectangle"
    ...
  
  def ellipse(self, x1, y1, x2, y2, stroke=..., fill=...): # -> None:
    """Uses bezierArc, which conveniently handles 360 degrees -
        nice touch Robert"""
    ...
  
  def wedge(self, x1, y1, x2, y2, startAng, extent, stroke=..., fill=...): # -> None:
    """Like arc, but connects to the centre of the ellipse.
        Most useful for pie charts and PacMan!"""
    ...
  
  def circle(self, x_cen, y_cen, r, stroke=..., fill=...): # -> None:
    """special case of ellipse"""
    ...
  
  def roundRect(self, x, y, width, height, radius, stroke=..., fill=...): # -> None:
    """Draws a rectangle with rounded corners.  The corners are
        approximately quadrants of a circle, with the given radius."""
    ...
  
  def drawString(self, x, y, text): # -> None:
    """Draws a string in the current text styles."""
    ...
  
  def drawRightString(self, x, y, text): # -> None:
    """Draws a string right-aligned with the y coordinate"""
    ...
  
  def drawCentredString(self, x, y, text): # -> None:
    """Draws a string right-aligned with the y coordinate.  I
        am British so the spelling is correct, OK?"""
    ...
  
  def getAvailableFonts(self): # -> KeysView[Unknown]:
    """Returns the list of PostScript font names available.
        Standard set now, but may grow in future with font embedding."""
    ...
  
  def setFont(self, psfontname, size, leading=...): # -> None:
    """Sets the font.  If leading not specified, defaults to 1.2 x
        font size. Raises a readable exception if an illegal font
        is supplied.  Font names are case-sensitive! Keeps track
        of font anme and size for metrics."""
    ...
  
  def stringWidth(self, text, fontname, fontsize):
    "gets width of a string in the given font and size"
    ...
  
  def setLineWidth(self, width): # -> None:
    ...
  
  def setLineCap(self, mode): # -> None:
    """0=butt,1=round,2=square"""
    ...
  
  def setLineJoin(self, mode): # -> None:
    """0=mitre, 1=round, 2=bevel"""
    ...
  
  def setMiterLimit(self, limit): # -> None:
    ...
  
  def setDash(self, array=..., phase=...): # -> None:
    """Two notations.  pass two numbers, or an array and phase"""
    ...
  
  def setFillColorRGB(self, r, g, b): # -> None:
    ...
  
  def setStrokeColorRGB(self, r, g, b): # -> None:
    ...
  
  def beginPath(self): # -> PDFPathObject:
    """Returns a fresh path object"""
    ...
  
  def drawPath(self, aPath, stroke=..., fill=...): # -> None:
    "Draw in the mode indicated"
    ...
  
  def clipPath(self, aPath, stroke=..., fill=...): # -> None:
    "clip as well as drawing"
    ...
  
  def beginText(self, x=..., y=...): # -> PDFTextObject:
    """Returns a fresh text object"""
    ...
  
  def drawText(self, aTextObject): # -> None:
    """Draws a text object"""
    ...
  
  def drawInlineImage(self, image, x, y, width=..., height=...): # -> None:
    """Draw a PIL Image into the specified rectangle.  If width and
        height are omitted, they are calculated from the image size.
        Also allow file names as well as images.  This allows a
        caching mechanism"""
    ...
  
  def readJPEGInfo(self, image): # -> tuple[Any, Any, Any] | None:
    "Read width, height and number of components from JPEG file"
    ...
  
  def setPageCompression(self, onoff=...): # -> None:
    """Possible values 1 or 0 (1 for 'on' is the default).
        If on, the page data will be compressed, leading to much
        smaller files, but takes a little longer to create the files.
        This applies to all subsequent pages, or until setPageCompression()
        is next called."""
    ...
  
  def setPageTransition(self, effectname=..., duration=..., direction=..., dimension=..., motion=...): # -> None:
    """PDF allows page transition effects for use when giving
        presentations.  There are six possible effects.  You can
        just guive the effect name, or supply more advanced options
        to refine the way it works.  There are three types of extra
        argument permitted, and here are the allowed values:
            direction_arg = [0,90,180,270]
            dimension_arg = ['H', 'V']
            motion_arg = ['I','O'] (start at inside or outside)

        This table says which ones take which arguments:

        PageTransitionEffects = {
            'Split': [direction_arg, motion_arg],
            'Blinds': [dimension_arg],
            'Box': [motion_arg],
            'Wipe' : [direction_arg],
            'Dissolve' : [],
            'Glitter':[direction_arg]
            }
        Have fun!
"""
    ...
  


class PDFPathObject:
  """Represents a graphic path.  There are certain 'modes' to PDF
    drawing, and making a separate object to expose Path operations
    ensures they are completed with no run-time overhead.  Ask
    the Canvas for a PDFPath with getNewPathObject(); moveto/lineto/
    curveto wherever you want; add whole shapes; and then add it back
    into the canvas with one of the relevant operators.

    Path objects are probably not long, so we pack onto one line"""
  def __init__(self) -> None:
    ...
  
  def getCode(self): # -> str:
    "pack onto one line; used internally"
    ...
  
  def moveTo(self, x, y): # -> None:
    ...
  
  def lineTo(self, x, y): # -> None:
    ...
  
  def curveTo(self, x1, y1, x2, y2, x3, y3): # -> None:
    ...
  
  def arc(self, x1, y1, x2, y2, startAng=..., extent=...): # -> None:
    """Contributed to piddlePDF by Robert Kern, 28/7/99.
        Draw a partial ellipse inscribed within the rectangle x1,y1,x2,y2,
        starting at startAng degrees and covering extent degrees.   Angles
        start with 0 to the right (+x) and increase counter-clockwise.
        These should have x1<x2 and y1<y2.

        The algorithm is an elliptical generalization of the formulae in
        Jim Fitzsimmon's TeX tutorial <URL: http://www.tinaja.com/bezarc1.pdf>."""
    ...
  
  def arcTo(self, x1, y1, x2, y2, startAng=..., extent=...): # -> None:
    """Like arc, but draws a line from the current point to
        the start if the start is not the current point."""
    ...
  
  def rect(self, x, y, width, height): # -> None:
    """Adds a rectangle to the path"""
    ...
  
  def ellipse(self, x, y, width, height): # -> None:
    """adds an ellipse to the path"""
    ...
  
  def circle(self, x_cen, y_cen, r): # -> None:
    """adds a circle to the path"""
    ...
  
  def close(self): # -> None:
    "draws a line back to where it started"
    ...
  


class PDFTextObject:
  """PDF logically separates text and graphics drawing; you can
    change the coordinate systems for text and graphics independently.
    If you do drawings while in text mode, they appear in the right places
    on the page in Acrobat Reader, bur when you export Postscript to
    a printer the graphics appear relative to the text coordinate
    system.  I regard this as a bug in how Acrobat exports to PostScript,
    but this is the workaround.  It forces the user to separate text
    and graphics.  To output text, ask te canvas for a text object
    with beginText(x, y).  Do not construct one directly. It keeps
    track of x and y coordinates relative to its origin."""
  def __init__(self, canvas, x=..., y=...) -> None:
    ...
  
  def getCode(self): # -> str:
    "pack onto one line; used internally"
    ...
  
  def setTextOrigin(self, x, y): # -> None:
    ...
  
  def setTextTransform(self, a, b, c, d, e, f): # -> None:
    "Like setTextOrigin, but does rotation, scaling etc."
    ...
  
  def moveCursor(self, dx, dy): # -> None:
    """Moves to a point dx, dy away from the start of the
        current line - NOT from the current point! So if
        you call it in mid-sentence, watch out."""
    ...
  
  def getCursor(self): # -> tuple[Unknown, Unknown]:
    """Returns current text position relative to the last origin."""
    ...
  
  def getX(self):
    """Returns current x position relative to the last origin."""
    ...
  
  def getY(self):
    """Returns current y position relative to the last origin."""
    ...
  
  def setFont(self, psfontname, size, leading=...): # -> None:
    """Sets the font.  If leading not specified, defaults to 1.2 x
        font size. Raises a readable exception if an illegal font
        is supplied.  Font names are case-sensitive! Keeps track
        of font anme and size for metrics."""
    ...
  
  def setCharSpace(self, charSpace): # -> None:
    """Adjusts inter-character spacing"""
    ...
  
  def setWordSpace(self, wordSpace): # -> None:
    """Adjust inter-word spacing.  This can be used
        to flush-justify text - you get the width of the
        words, and add some space between them."""
    ...
  
  def setHorizScale(self, horizScale): # -> None:
    "Stretches text out horizontally"
    ...
  
  def setLeading(self, leading): # -> None:
    "How far to move down at the end of a line."
    ...
  
  def setTextRenderMode(self, mode): # -> None:
    """Set the text rendering mode.

        0 = Fill text
        1 = Stroke text
        2 = Fill then stroke
        3 = Invisible
        4 = Fill text and add to clipping path
        5 = Stroke text and add to clipping path
        6 = Fill then stroke and add to clipping path
        7 = Add to clipping path"""
    ...
  
  def setRise(self, rise): # -> None:
    "Move text baseline up or down to allow superscrip/subscripts"
    ...
  
  def setStrokeColorRGB(self, r, g, b): # -> None:
    ...
  
  def setFillColorRGB(self, r, g, b): # -> None:
    ...
  
  def textOut(self, text): # -> None:
    "prints string at current point, text cursor moves across"
    ...
  
  def textLine(self, text=...): # -> None:
    """prints string at current point, text cursor moves down.
        Can work with no argument to simply move the cursor down."""
    ...
  
  def textLines(self, stuff, trim=...): # -> None:
    """prints multi-line or newlined strings, moving down.  One
        common use is to quote a multi-line block in your Python code;
        since this may be indented, by default it trims whitespace
        off each line and from the beginning; set trim=0 to preserve
        whitespace."""
    ...
  


if __name__ == '__main__':
  ...
