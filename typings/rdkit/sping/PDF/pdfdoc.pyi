"""
This type stub file was generated by pyright.
"""

from types import *

""" 
PDFgen is a library to generate PDF files containing text and graphics.  It is the 
foundation for a complete reporting solution in Python.  

The module pdfdoc.py handles the 'outer structure' of PDF documents, ensuring that
all objects are properly cross-referenced and indexed to the nearest byte.  The 
'inner structure' - the page descriptions - are presumed to be generated before 
each page is saved.
pdfgen.py calls this and provides a 'canvas' object to handle page marking operators.
piddlePDF calls pdfgen and offers a high-level interface.

(C) Copyright Andy Robinson 1998-1999
"""
StandardEnglishFonts = ...
PDFError = ...
AFMDIR = ...
A4 = ...
class PDFDocument:
  """Responsible for linking and writing out the whole document.
    Builds up a list of objects using add(key, object).  Each of these
    must inherit from PDFObject and be able to write itself into the file.
    For cross-linking, it provides getPosition(key) which tells you where
    another object is, or raises a KeyError if not found.  The rule is that
    objects should only refer ones previously written to file.
    """
  def __init__(self) -> None:
    ...
  
  def add(self, key, obj): # -> int:
    ...
  
  def getPosition(self, key):
    """Tell you where the given object is in the file - used for
        cross-linking; an object can call self.doc.getPosition("Page001")
        to find out where the object keyed under "Page001" is stored."""
    ...
  
  def setTitle(self, title): # -> None:
    "embeds in PDF file"
    ...
  
  def setAuthor(self, author): # -> None:
    "embedded in PDF file"
    ...
  
  def setSubject(self, subject): # -> None:
    "embeds in PDF file"
    ...
  
  def printXref(self): # -> None:
    ...
  
  def writeXref(self, f): # -> None:
    ...
  
  def printTrailer(self): # -> None:
    ...
  
  def writeTrailer(self, f): # -> None:
    ...
  
  def SaveToFile(self, filename): # -> None:
    ...
  
  def SaveToFileObject(self, fileobj): # -> None:
    """Open a file, and ask each object in turn to write itself to
        the file.  Keep track of the file position at each point for
        use in the index at the end"""
    ...
  
  def printPDF(self): # -> None:
    "prints it to standard output.  Logs positions for doing trailer"
    ...
  
  def addPage(self, page): # -> None:
    """adds page and stream at end.  Maintains pages list"""
    ...
  
  def hasFont(self, psfontname): # -> bool:
    ...
  
  def getInternalFontName(self, psfontname):
    ...
  
  def getAvailableFonts(self): # -> KeysView[Unknown]:
    ...
  


class OutputGrabber:
  """At times we need to put something in the place of standard
    output.  This grabs stdout, keeps the data, and releases stdout
    when done.
    
    NOT working well enough!"""
  def __init__(self) -> None:
    ...
  
  def write(self, x): # -> None:
    ...
  
  def getData(self): # -> str:
    ...
  
  def close(self): # -> None:
    ...
  
  def __del__(self): # -> None:
    ...
  


def testOutputGrabber(): # -> None:
  ...

class PDFObject:
  """Base class for all PDF objects.  In PDF, precise measurement
    of file offsets is essential, so the usual trick of just printing
    and redirecting output has proved to give different behaviour on
    Mac and Windows.  While it might be soluble, I'm taking charge
    of line ends at the binary level and explicitly writing to a file.
    The LINEEND constant lets me try CR, LF and CRLF easily to help
    pin down the problem."""
  def save(self, file): # -> None:
    "Save its content to an open file"
    ...
  
  def printPDF(self): # -> None:
    ...
  


class PDFLiteral(PDFObject):
  " a ready-made one you wish to quote"
  def __init__(self, text) -> None:
    ...
  
  def save(self, file): # -> None:
    ...
  


class PDFCatalog(PDFObject):
  "requires RefPages and RefOutlines set"
  def __init__(self) -> None:
    ...
  
  def save(self, file): # -> None:
    ...
  


class PDFInfo(PDFObject):
  """PDF documents can have basic information embedded, viewable from
    File | Document Info in Acrobat Reader.  If this is wrong, you get
    Postscript errors while printing, even though it does not print."""
  def __init__(self) -> None:
    ...
  
  def save(self, file): # -> None:
    ...
  


class PDFOutline(PDFObject):
  "null outline, does nothing yet"
  def __init__(self) -> None:
    ...
  
  def save(self, file): # -> None:
    ...
  


class PDFPageCollection(PDFObject):
  "presumes PageList attribute set (list of integers)"
  def __init__(self) -> None:
    ...
  
  def save(self, file): # -> None:
    ...
  


class PDFPage(PDFObject):
  """The Bastard.  Needs list of Resources etc. Use a standard one for now.
    It manages a PDFStream object which must be added to the document's list
    of objects as well."""
  def __init__(self) -> None:
    ...
  
  def setCompression(self, onoff=...): # -> None:
    "Turns page compression on or off"
    ...
  
  def save(self, file): # -> None:
    ...
  
  def clear(self): # -> None:
    ...
  
  def setStream(self, data): # -> None:
    ...
  


TestStream = ...
class PDFStream(PDFObject):
  "Used for the contents of a page"
  def __init__(self) -> None:
    ...
  
  def setStream(self, data): # -> None:
    ...
  
  def save(self, file): # -> None:
    ...
  


class PDFImage(PDFObject):
  def save(self, file): # -> None:
    ...
  


class PDFType1Font(PDFObject):
  def __init__(self, key, font) -> None:
    ...
  
  def save(self, file): # -> None:
    ...
  


def MakeType1Fonts(): # -> list[Unknown]:
  "returns a list of all the standard font objects"
  ...

def MakeFontDictionary(startpos, count): # -> str:
  "returns a font dictionary assuming they are all in the file from startpos"
  ...

if __name__ == '__main__':
  ...
