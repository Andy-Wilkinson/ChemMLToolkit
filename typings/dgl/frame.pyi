"""
This type stub file was generated by pyright.
"""

from collections import namedtuple
from collections.abc import MutableMapping

"""Columnar storage for DGLGraph."""
class Scheme(namedtuple('Scheme', ['shape', 'dtype'])):
    """The column scheme.

    Parameters
    ----------
    shape : tuple of int
        The feature shape.
    dtype : backend-specific type object
        The feature data type.
    """
    def __reduce__(self): # -> tuple[(shape: Unknown, dtype_str: Unknown) -> Self@Scheme, tuple[Unknown, Unknown]]:
        ...
    


def infer_scheme(tensor): # -> Scheme:
    """Infer column scheme from the given tensor data.

    Parameters
    ---------
    tensor : Tensor
        The tensor data.

    Returns
    -------
    Scheme
        The column scheme.
    """
    ...

class Column:
    """A column is a compact store of features of multiple nodes/edges.

    It batches all the feature tensors together along the first dimension
    as one dense tensor.

    The column can optionally have an index tensor I.
    In this case, the i^th feature is stored in ``storage[index[i]]``.
    The column class implements a Copy-On-Read semantics -- the index
    select operation happens upon the first read of the feature data.
    This is useful when one extracts a subset of the feature data
    but wishes the actual index select happens on-demand.

    Parameters
    ----------
    storage : Tensor
        The feature data storage.
    scheme : Scheme, optional
        The scheme of the column. Will be inferred if not provided.
    index : Tensor, optional
        The row index to the feature data storage. None means an
        identity mapping.

    Attributes
    ----------
    storage : Tensor
        The storage tensor. The storage tensor may not be the actual data
        tensor of this column when the index tensor is not None.
        This typically happens when the column is extracted from another
        column using the `subcolumn` method.

        It can also be None, which may only happen when transmitting a
        not-yet-materialized subcolumn from a subprocess to the main process.
        In this case, the main process should already maintain the content of
        the storage, and is responsible for restoring the subcolumn's storage pointer.
    data : Tensor
        The actual data tensor of this column.
    scheme : Scheme
        The scheme of the column.
    index : Tensor
        Index tensor
    """
    def __init__(self, storage, scheme=..., index=..., device=...) -> None:
        ...
    
    def __len__(self): # -> int:
        """The number of features (number of rows) in this column."""
        ...
    
    @property
    def shape(self):
        """Return the scheme shape (feature shape) of this column."""
        ...
    
    @property
    def data(self):
        """Return the feature data. Perform index selecting if needed."""
        ...
    
    @data.setter
    def data(self, val): # -> None:
        """Update the column data."""
        ...
    
    def to(self, device, **kwargs): # -> Column:
        """ Return a new column with columns copy to the targeted device (cpu/gpu).

        Parameters
        ----------
        device : Framework-specific device context object
            The context to move data to.
        kwargs : Key-word arguments.
            Key-word arguments fed to the framework copy function.

        Returns
        -------
        Column
            A new column
        """
        ...
    
    def __getitem__(self, rowids):
        """Return the feature data given the rowids.

        The operation triggers index selection.

        Parameters
        ----------
        rowids : Tensor
            Row ID tensor.

        Returns
        -------
        Tensor
            The feature data
        """
        ...
    
    def __setitem__(self, rowids, feats): # -> None:
        """Update the feature data given the index.

        The update is performed out-placely so it can be used in autograd mode.
        The operation triggers index selection.

        Parameters
        ----------
        rowids : Tensor
            Row IDs.
        feats : Tensor
            New features.
        """
        ...
    
    def update(self, rowids, feats): # -> None:
        """Update the feature data given the index.

        Parameters
        ----------
        rowids : Tensor
            Row IDs.
        feats : Tensor
            New features.
        """
        ...
    
    def extend(self, feats, feat_scheme=...): # -> None:
        """Extend the feature data.

        The operation triggers index selection.

        Parameters
        ----------
        feats : Tensor
            The new features.
        feat_scheme : Scheme, optional
            The scheme
        """
        ...
    
    def clone(self): # -> Column:
        """Return a shallow copy of this column."""
        ...
    
    def deepclone(self): # -> Column:
        """Return a deepcopy of this column.

        The operation triggers index selection.
        """
        ...
    
    def subcolumn(self, rowids): # -> Column:
        """Return a subcolumn.

        The resulting column will share the same storage as this column so this operation
        is quite efficient. If the current column is also a sub-column (i.e., the
        index tensor is not None), it slices the index tensor with the given
        rowids as the index tensor of the resulting column.

        Parameters
        ----------
        rowids : Tensor
            Row IDs.

        Returns
        -------
        Column
            Sub-column
        """
        ...
    
    @staticmethod
    def create(data): # -> Column:
        """Create a new column using the given data."""
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        ...
    
    def __copy__(self): # -> Column:
        ...
    


class Frame(MutableMapping):
    """The columnar storage for node/edge features.

    The frame is a dictionary from feature names to feature columns.
    All columns should have the same number of rows (i.e. the same first dimension).

    Parameters
    ----------
    data : dict-like, optional
        The frame data in dictionary. If the provided data is another frame,
        this frame will NOT share columns with the given frame. So any out-place
        update on one will not reflect to the other.
    num_rows : int, optional
        The number of rows in this frame. If ``data`` is provided and is not empty,
        ``num_rows`` will be ignored and inferred from the given data.
    """
    def __init__(self, data=..., num_rows=...) -> None:
        ...
    
    def get_initializer(self, column=...): # -> (shape: Unknown, dtype: Unknown, ctx: Unknown, id_range: Unknown) -> Unknown | None:
        """Get the initializer for empty values for the given column.

        Parameters
        ----------
        column : str
            The column

        Returns
        -------
        callable
            The initializer
        """
        ...
    
    def set_initializer(self, initializer, column=...): # -> None:
        """Set the initializer for empty values, for a given column or all future
        columns.

        Initializer is a callable that returns a tensor given the shape and data type.

        Parameters
        ----------
        initializer : callable
            The initializer.
        column : str, optional
            The column name
        """
        ...
    
    @property
    def schemes(self): # -> dict[Unknown, Unknown | Scheme]:
        """Return a dictionary of column name to column schemes."""
        ...
    
    @property
    def num_columns(self): # -> int:
        """Return the number of columns in this frame."""
        ...
    
    @property
    def num_rows(self): # -> int | Unknown:
        """Return the number of rows in this frame."""
        ...
    
    def __contains__(self, name): # -> bool:
        """Return true if the given column name exists."""
        ...
    
    def __getitem__(self, name):
        """Return the column of the given name.

        Parameters
        ----------
        name : str
            The column name.

        Returns
        -------
        Tensor
            Column data.
        """
        ...
    
    def __setitem__(self, name, data): # -> None:
        """Update the whole column.

        Parameters
        ----------
        name : str
            The column name.
        col : Column or data convertible to Column
            The column data.
        """
        ...
    
    def __delitem__(self, name): # -> None:
        """Delete the whole column.

        Parameters
        ----------
        name : str
            The column name.
        """
        ...
    
    def add_column(self, name, scheme, ctx): # -> None:
        """Add a new column to the frame.

        The frame will be initialized by the initializer.

        Parameters
        ----------
        name : str
            The column name.
        scheme : Scheme
            The column scheme.
        ctx : DGLContext
            The column context.
        """
        ...
    
    def add_rows(self, num_rows): # -> None:
        """Add blank rows to this frame.

        For existing fields, the rows will be extended according to their
        initializers.

        Parameters
        ----------
        num_rows : int
            The number of new rows
        """
        ...
    
    def update_column(self, name, data): # -> None:
        """Add or replace the column with the given name and data.

        Parameters
        ----------
        name : str
            The column name.
        data : Column or data convertible to Column
            The column data.
        """
        ...
    
    def update_row(self, rowids, data): # -> None:
        """Update the feature data of the given rows.

        If the data contains new keys (new columns) that do not exist in
        this frame, add a new column.

        The ``rowids`` shall not contain duplicates. Otherwise, the behavior
        is undefined.

        Parameters
        ----------
        rowids : Tensor
            Row Ids.
        data : dict[str, Tensor]
            Row data.
        """
        ...
    
    def append(self, other): # -> None:
        """Append another frame's data into this frame.

        If the current frame is empty, it will just use the columns of the
        given frame. Otherwise, the given data should contain all the
        column keys of this frame.

        Parameters
        ----------
        other : Frame or dict-like
            The frame data to be appended.
        """
        ...
    
    def clear(self): # -> None:
        """Clear this frame. Remove all the columns."""
        ...
    
    def __iter__(self): # -> Iterator[Unknown]:
        """Return an iterator of columns."""
        ...
    
    def __len__(self): # -> int:
        """Return the number of columns."""
        ...
    
    def keys(self): # -> _dict_keys[Unknown, Unknown] | _dict_keys[Unknown, Column]:
        """Return the keys."""
        ...
    
    def values(self): # -> _dict_values[Unknown, Unknown] | _dict_values[Column, Unknown]:
        """Return the values."""
        ...
    
    def clone(self): # -> Frame:
        """Return a clone of this frame.

        The clone frame does not share the underlying storage with this frame,
        i.e., adding or removing columns will not be visible to each other. However,
        they still share the tensor contents so any mutable operation on the column
        tensor are visible to each other. Hence, the function does not allocate extra
        tensor memory. Use :func:`~dgl.Frame.deepclone` for cloning
        a frame that does not share any data.

        Returns
        -------
        Frame
            A cloned frame.
        """
        ...
    
    def deepclone(self): # -> Frame:
        """Return a deep clone of this frame.

        The clone frame has an copy of this frame and any modification to the clone frame
        is not visible to this frame. The function allocate new tensors and copy the contents
        from this frame. Use :func:`~dgl.Frame.clone` for cloning a frame that does not
        allocate extra tensor memory.

        Returns
        -------
        Frame
            A deep-cloned frame.
        """
        ...
    
    def subframe(self, rowids): # -> Frame:
        """Return a new frame whose columns are subcolumns of this frame.

        The given row IDs should be within range [0, self.num_rows), and allow
        duplicate IDs.

        Parameters
        ----------
        rowids : Tensor
            Row IDs

        Returns
        -------
        Frame
            A new subframe.
        """
        ...
    
    def to(self, device, **kwargs): # -> Frame:
        """ Return a new frame with columns copy to the targeted device (cpu/gpu).

        Parameters
        ----------
        device : Framework-specific device context object
            The context to move data to.
        kwargs : Key-word arguments.
            Key-word arguments fed to the framework copy function.

        Returns
        -------
        Frame
            A new frame
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    


