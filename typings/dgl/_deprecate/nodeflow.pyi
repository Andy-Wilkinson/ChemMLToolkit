"""
This type stub file was generated by pyright.
"""

from .._ffi.object import ObjectBase, register_object
from .graph import DGLBaseGraph

"""Class for NodeFlow data structure."""
__all__ = ['NodeFlow']
@register_object('graph.NodeFlow')
class NodeFlowObject(ObjectBase):
    """NodeFlow object"""
    @property
    def graph(self):
        """The graph structure of this nodeflow.

        Returns
        -------
        GraphIndex
        """
        ...
    
    @property
    def layer_offsets(self):
        """The offsets of each layer.

        Returns
        -------
        NDArray
        """
        ...
    
    @property
    def block_offsets(self):
        """The offsets of each block.

        Returns
        -------
        NDArray
        """
        ...
    
    @property
    def node_mapping(self):
        """Mapping array from nodeflow node id to parent graph

        Returns
        -------
        NDArray
        """
        ...
    
    @property
    def edge_mapping(self):
        """Mapping array from nodeflow edge id to parent graph

        Returns
        -------
        NDArray
        """
        ...
    


class NodeFlow(DGLBaseGraph):
    """The NodeFlow class stores the sampling results of Neighbor
    sampling and Layer-wise sampling.

    These sampling algorithms generate graphs with multiple layers. The
    edges connect the nodes between two layers, which forms *blocks*, while
    there don't exist edges between the nodes in the same layer. As illustrated
    in the figure, the last layer stores the target (seed) nodes where neighbors
    are sampled from. Neighbors reached in different hops are placed in different
    layers. Edges that connect to the neighbors in the next hop are placed
    in a block.
    We store extra information, such as the node and edge mapping from
    the NodeFlow graph to the parent graph.

    .. image:: https://data.dgl.ai/api/sampling.nodeflow.png

    DO NOT create NodeFlow object directly. Use sampling method to
    generate NodeFlow instead.

    Parameters
    ----------
    parent : DGLGraphStale
        The parent graph.
    nfobj : NodeFlowObject
        The nodeflow object
    """
    def __init__(self, parent, nfobj) -> None:
        ...
    
    @property
    def num_layers(self): # -> int:
        """Get the number of layers.

        Returns
        -------
        int
            the number of layers
        """
        ...
    
    @property
    def num_blocks(self): # -> int:
        """Get the number of blocks.

        Returns
        -------
        int
            the number of blocks
        """
        ...
    
    @property
    def layers(self): # -> LayerView:
        """Return a LayerView of this NodeFlow.

        This is mainly for usage like:
        * `g.layers[2].data['h']` to get the node features of layer#2.
        """
        ...
    
    @property
    def blocks(self): # -> BlockView:
        """Return a BlockView of this NodeFlow.

        This is mainly for usage like:
        * `g.blocks[1].data['h']` to get the edge features of blocks from layer#1 to layer#2.
        """
        ...
    
    def node_attr_schemes(self, layer_id): # -> dict[Unknown, Unknown | Scheme | None]:
        """Return the node feature schemes.

        Each feature scheme is a named tuple that stores the shape and data type
        of the node feature

        Parameters
        ----------
        layer_id : int
            the specified layer to get node data scheme.

        Returns
        -------
        dict of str to schemes
            The schemes of node feature columns.
        """
        ...
    
    def edge_attr_schemes(self, block_id): # -> dict[Unknown, Unknown | Scheme | None]:
        """Return the edge feature schemes.

        Each feature scheme is a named tuple that stores the shape and data type
        of the node feature

        Parameters
        ----------
        block_id : int
            the specified block to get edge data scheme.

        Returns
        -------
        dict of str to schemes
            The schemes of edge feature columns.
        """
        ...
    
    def layer_size(self, layer_id): # -> int:
        """Return the number of nodes in a specified layer.

        Parameters
        ----------
        layer_id : int
            the specified layer to return the number of nodes.
        """
        ...
    
    def block_size(self, block_id): # -> int:
        """Return the number of edges in a specified block.

        Parameters
        ----------
        block_id : int
            the specified block to return the number of edges.
        """
        ...
    
    def copy_from_parent(self, node_embed_names=..., edge_embed_names=..., ctx=...):
        """Copy node/edge features from the parent graph.

        Parameters
        ----------
        node_embed_names : a list of lists of strings, optional
            The names of embeddings in each layer.
        edge_embed_names : a list of lists of strings, optional
            The names of embeddings in each block.
        ctx : Context
            The device to copy tensor to. If None, features will stay at its original device
        """
        ...
    
    def copy_to_parent(self, node_embed_names=..., edge_embed_names=...):
        """Copy node/edge embeddings to the parent graph.

        Note: if a node in the parent graph appears in multiple layers and they
        in the NodeFlow has node data with the same name, the data of this node
        in the lower layer will overwrite the node data in previous layer.

        For example, node 5 in the parent graph appears in layer 0 and 1 and
        they have the same node data 'h'. The node data in layer 1 of this node
        will overwrite its data in layer 0 when copying the data back.

        To avoid this, users can give node data in each layer a different name.

        Parameters
        ----------
        node_embed_names : a list of lists of strings, optional
            The names of embeddings in each layer.
        edge_embed_names : a list of lists of strings, optional
            The names of embeddings in each block.
        """
        ...
    
    def map_to_parent_nid(self, nid):
        """This maps the child node Ids to the parent Ids.

        Parameters
        ----------
        nid : tensor
            The node ID array in the NodeFlow graph.

        Returns
        -------
        Tensor
            The parent node id array.
        """
        ...
    
    def map_to_parent_eid(self, eid):
        """This maps the child edge Ids to the parent Ids.

        Parameters
        ----------
        nid : tensor
            The edge ID array in the NodeFlow graph.

        Returns
        -------
        Tensor
            The parent edge id array.
        """
        ...
    
    def map_from_parent_nid(self, layer_id, parent_nids, remap_local=...):
        """Map parent node Ids to NodeFlow node Ids in a certain layer.

        If `remap_local` is True, it returns the node Ids local to the layer.
        Otherwise, the node Ids are unique in the NodeFlow.

        Parameters
        ----------
        layer_id : int
            The layer Id.
        parent_nids: list or Tensor
            Node Ids in the parent graph.
        remap_local: boolean
            Remap layer/block-level local Id if True; otherwise, NodeFlow-level Id.

        Returns
        -------
        Tensor
            Node Ids in the NodeFlow.
        """
        ...
    
    def layer_in_degree(self, layer_id):
        """Return the in-degree of the nodes in the specified layer.

        Parameters
        ----------
        layer_id : int
            The layer Id.

        Returns
        -------
        Tensor
            The degree of the nodes in the specified layer.
        """
        ...
    
    def layer_out_degree(self, layer_id):
        """Return the out-degree of the nodes in the specified layer.

        Parameters
        ----------
        layer_id : int
            The layer Id.

        Returns
        -------
        Tensor
            The degree of the nodes in the specified layer.
        """
        ...
    
    def layer_nid(self, layer_id):
        """Get the node Ids in the specified layer.

        The returned node Ids are unique in the NodeFlow.

        Parameters
        ----------
        layer_id : int
            The layer to get the node Ids.

        Returns
        -------
        Tensor
            The node ids.
        """
        ...
    
    def layer_parent_nid(self, layer_id):
        """Get the node Ids of the parent graph in the specified layer

        layer_parent_nid(-1) returns seed vertices for this NodeFlow.

        Parameters
        ----------
        layer_id : int
            The layer to get the node Ids.

        Returns
        -------
        Tensor
            The parent node id array.
        """
        ...
    
    def block_eid(self, block_id):
        """Get the edge Ids in the specified block.

        The returned edge Ids are unique in the NodeFlow.

        Parameters
        ----------
        block_id : int
            the specified block to get edge Ids.

        Returns
        -------
        Tensor
            The edge ids of the block in the NodeFlow.
        """
        ...
    
    def block_parent_eid(self, block_id):
        """Get the edge Ids of the parent graph in the specified block.

        Parameters
        ----------
        block_id : int
            the specified block to get edge Ids.

        Returns
        -------
        Tensor
            The edge ids of the block in the parent graph.
        """
        ...
    
    def block_edges(self, block_id, remap_local=...): # -> tuple[Unknown, Unknown, Unknown]:
        """Return the edges in a block.

        If remap_local is True, returned indices u, v, eid will be remapped to local
        Ids (i.e. starting from 0) in the block or in the layer. Otherwise,
        u, v, eid are unique in the NodeFlow.

        Parameters
        ----------
        block_id : int
            The specified block to return the edges.
        remap_local : boolean
            Remap layer/block-level local Id if True; otherwise, NodeFlow-level Id.

        Returns
        -------
        Tensor
            The src nodes.
        Tensor
            The dst nodes.
        Tensor
            The edge ids.
        """
        ...
    
    def block_adjacency_matrix(self, block_id, ctx): # -> tuple[Unknown, Unknown]:
        """Return the adjacency matrix representation for a specific block in a NodeFlow.

        A row of the returned adjacency matrix represents the destination
        of an edge and the column represents the source.

        Parameters
        ----------
        block_id : int
            The specified block to return the adjacency matrix.
        ctx : context
            The context of the returned matrix.

        Returns
        -------
        SparseTensor
            The adjacency matrix.
        Tensor
            A index for data shuffling due to sparse format change. Return None
            if shuffle is not required.
        """
        ...
    
    def block_incidence_matrix(self, block_id, typestr, ctx): # -> tuple[Unknown, Unknown]:
        """Return the incidence matrix representation of the block.

        An incidence matrix is an n x m sparse matrix, where n is
        the number of nodes and m is the number of edges. Each nnz
        value indicating whether the edge is incident to the node
        or not.

        There are two types of an incidence matrix `I`:

        * ``in``:

            - I[v, e] = 1 if e is the in-edge of v (or v is the dst node of e);
            - I[v, e] = 0 otherwise.

        * ``out``:

            - I[v, e] = 1 if e is the out-edge of v (or v is the src node of e);
            - I[v, e] = 0 otherwise.

        "both" isn't defined in the block of a NodeFlow.

        Parameters
        ----------
        block_id : int
            The specified block to return the incidence matrix.
        typestr : str
            Can be either "in", "out" or "both"
        ctx : context
            The context of returned incidence matrix.

        Returns
        -------
        SparseTensor
            The incidence matrix.
        Tensor
            A index for data shuffling due to sparse format change. Return None
            if shuffle is not required.
        """
        ...
    
    def set_n_initializer(self, initializer, layer_id=..., field=...): # -> None:
        """Set the initializer for empty node features.

        Initializer is a callable that returns a tensor given the shape, data type
        and device context.

        When a subset of the nodes are assigned a new feature, initializer is
        used to create feature for rest of the nodes.

        Parameters
        ----------
        initializer : callable
            The initializer.
        layer_id : int
            the layer to set the initializer.
        field : str, optional
            The feature field name. Default is set an initializer for all the
            feature fields.
        """
        ...
    
    def set_e_initializer(self, initializer, block_id=..., field=...): # -> None:
        """Set the initializer for empty edge features.

        Initializer is a callable that returns a tensor given the shape, data
        type and device context.

        When a subset of the edges are assigned a new feature, initializer is
        used to create feature for rest of the edges.

        Parameters
        ----------
        initializer : callable
            The initializer.
        block_id : int
            the block to set the initializer.
        field : str, optional
            The feature field name. Default is set an initializer for all the
            feature fields.
        """
        ...
    
    def register_message_func(self, func, block_id=...): # -> None:
        """Register global message function for a block.

        Once registered, ``func`` will be used as the default
        message function in message passing operations, including
        :func:`block_compute`, :func:`prop_flow`.

        Parameters
        ----------
        func : callable
            Message function on the edge. The function should be
            an :mod:`Edge UDF <dgl.udf>`.
        block_id : int or ALL
            the block to register the message function.
        """
        ...
    
    def register_reduce_func(self, func, block_id=...): # -> None:
        """Register global message reduce function for a block.

        Once registered, ``func`` will be used as the default
        message reduce function in message passing operations, including
        :func:`block_compute`, :func:`prop_flow`.

        Parameters
        ----------
        func : callable
            Reduce function on the node. The function should be
            a :mod:`Node UDF <dgl.udf>`.
        block_id : int or ALL
            the block to register the reduce function.
        """
        ...
    
    def register_apply_node_func(self, func, block_id=...): # -> None:
        """Register global node apply function for a block.

        Once registered, ``func`` will be used as the default apply
        node function. Related operations include :func:`apply_layer`,
        :func:`block_compute`, :func:`prop_flow`.

        Parameters
        ----------
        func : callable
            Apply function on the nodes. The function should be
            a :mod:`Node UDF <dgl.udf>`.
        block_id : int or ALL
            the block to register the apply node function.
        """
        ...
    
    def register_apply_edge_func(self, func, block_id=...): # -> None:
        """Register global edge apply function for a block.

        Once registered, ``func`` will be used as the default apply
        edge function in :func:`apply_block`.

        Parameters
        ----------
        func : callable
            Apply function on the edge. The function should be
            an :mod:`Edge UDF <dgl.udf>`.
        block_id : int or ALL
            the block to register the apply edge function.
        """
        ...
    
    def apply_layer(self, layer_id, func=..., v=..., inplace=...): # -> None:
        """Apply node update function on the node embeddings in the specified layer.

        Parameters
        ----------
        layer_id : int
            The specified layer to update node embeddings.
        func : callable or None, optional
            Apply function on the nodes. The function should be
            a :mod:`Node UDF <dgl.udf>`.
        v : a list of vertex Ids or ALL.
            The vertex Ids (unique in the NodeFlow) to run the node update function.
        inplace : bool, optional
            If True, update will be done in place, but autograd will break.
        """
        ...
    
    def apply_block(self, block_id, func=..., edges=..., inplace=...): # -> None:
        """Apply edge update function on the edge embeddings in the specified layer.

        Parameters
        ----------
        block_id : int
            The specified block to update edge embeddings.
        func : callable or None, optional
            Apply function on the edges. The function should be
            an :mod:`Edge UDF <dgl.udf>`.
        edges : a list of edge Ids or ALL.
            The edges Id to run the edge update function.
        inplace : bool, optional
            If True, update will be done in place, but autograd will break.
        """
        ...
    
    def block_compute(self, block_id, message_func=..., reduce_func=..., apply_node_func=..., v=..., inplace=...): # -> None:
        """Perform the computation on the specified block. It's similar to `pull`
        in DGLGraphStale.
        On the given block i, it runs `pull` on nodes in layer i+1, which generates
        messages on edges in block i, runs the reduce function and node update
        function on nodes in layer i+1.

        Parameters
        ----------
        block_id : int
            The block to run the computation.
        message_func : callable, optional
            Message function on the edges. The function should be
            an :mod:`Edge UDF <dgl.udf>`.
        reduce_func : callable, optional
            Reduce function on the node. The function should be
            a :mod:`Node UDF <dgl.udf>`.
        apply_node_func : callable, optional
            Apply function on the nodes. The function should be
            a :mod:`Node UDF <dgl.udf>`.
        v : a list of vertex Ids or ALL.
            The Node Ids (unique in the NodeFlow) in layer block_id+1 to run the computation.
        inplace: bool, optional
            If True, update will be done in place, but autograd will break.
        """
        ...
    
    def prop_flow(self, message_funcs=..., reduce_funcs=..., apply_node_funcs=..., flow_range=..., inplace=...):
        """Perform the computation on flows. By default, it runs on all blocks, one-by-one.
        On block i, it runs `pull` on nodes in layer i+1, which generates
        messages on edges in block i, runs the reduce function and node update
        function on nodes in layer i+1.

        Users can specify a list of message functions, reduce functions and
        node apply functions, one for each block. Thus, when a list is given,
        the length of the list should be the same as the number of blocks.

        Parameters
        ----------
        message_funcs : a callable, a list of callable, optional
            Message functions on the edges. The function should be
            an :mod:`Edge UDF <dgl.udf>`.
        reduce_funcs : a callable, a list of callable, optional
            Reduce functions on the node. The function should be
            a :mod:`Node UDF <dgl.udf>`.
        apply_node_funcs : a callable, a list of callable, optional
            Apply functions on the nodes. The function should be
            a :mod:`Node UDF <dgl.udf>`.
        flow_range : int or a slice or ALL.
            The specified blocks to run the computation.
        inplace: bool, optional
            If True, update will be done in place, but autograd will break.
        """
        ...
    
    @property
    def canonical_etype(self): # -> tuple[None, None, None]:
        """Return canonical edge type to be compatible with GraphAdapter
        """
        ...
    


