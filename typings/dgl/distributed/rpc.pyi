"""
This type stub file was generated by pyright.
"""

import abc
from .._ffi.object import ObjectBase, register_object

"""RPC components. They are typically functions or utilities used by both
server and clients."""
__all__ = ['set_rank', 'get_rank', 'Request', 'Response', 'register_service', 'create_sender', 'create_receiver', 'finalize_sender', 'finalize_receiver', 'receiver_wait', 'add_receiver_addr', 'sender_connect', 'read_ip_config', 'get_num_machines', 'set_num_machines', 'get_machine_id', 'set_machine_id', 'send_request', 'recv_request', 'send_response', 'recv_response', 'remote_call', 'send_request_to_machine', 'remote_call_to_machine', 'fast_pull', 'get_num_client', 'set_num_client', 'client_barrier', 'copy_data_to_shared_memory']
REQUEST_CLASS_TO_SERVICE_ID = ...
RESPONSE_CLASS_TO_SERVICE_ID = ...
SERVICE_ID_TO_PROPERTY = ...
DEFUALT_PORT = ...
def read_ip_config(filename, num_servers):
    """Read network configuration information of server from file.

    For exampple, the following TXT shows a 4-machine configuration:

        172.31.40.143
        172.31.36.140
        172.31.47.147
        172.31.30.180

    Users can also set user-specified port for this network configuration. For example:

        172.31.40.143 20090
        172.31.36.140 20090
        172.31.47.147 20090
        172.31.30.180 20090

    Note that, DGL supports multiple backup servers that shares data with each others
    on the same machine via shared-memory tensor. The num_servers should be >= 1. For example,
    if we set num_servers to 5, it means that we have 1 main server and 4 backup servers on
    current machine.

    Parameters
    ----------
    filename : str
        Path of IP configuration file.

    num_servers : int
        Server count on each machine.

    Returns
    -------
    dict
        server namebook.
        The key is server_id (int)
        The value is [machine_id, ip, port, num_servers] ([int, str, int, int])

        e.g.,

          {0:[0, '172.31.40.143', 30050, 2],
           1:[0, '172.31.40.143', 30051, 2],
           2:[1, '172.31.36.140', 30050, 2],
           3:[1, '172.31.36.140', 30051, 2],
           4:[2, '172.31.47.147', 30050, 2],
           5:[2, '172.31.47.147', 30051, 2],
           6:[3, '172.31.30.180', 30050, 2],
           7:[3, '172.31.30.180', 30051, 2]}
    """
    ...

def reset(): # -> None:
    """Reset the rpc context
    """
    ...

def create_sender(max_queue_size, net_type): # -> None:
    """Create rpc sender of this process.

    Parameters
    ----------
    max_queue_size : int
        Maximal size (bytes) of network queue buffer.
    net_type : str
        Networking type. Current options are: 'socket'.
    """
    ...

def create_receiver(max_queue_size, net_type): # -> None:
    """Create rpc receiver of this process.

    Parameters
    ----------
    max_queue_size : int
        Maximal size (bytes) of network queue buffer.
    net_type : str
        Networking type. Current options are: 'socket'.
    """
    ...

def finalize_sender(): # -> None:
    """Finalize rpc sender of this process.
    """
    ...

def finalize_receiver(): # -> None:
    """Finalize rpc receiver of this process.
    """
    ...

def receiver_wait(ip_addr, port, num_senders): # -> None:
    """Wait all of the senders' connections.

    This api will be blocked until all the senders connect to the receiver.

    Parameters
    ----------
    ip_addr : str
        receiver's IP address, e,g, '192.168.8.12'
    port : int
        receiver's port
    num_senders : int
        total number of senders
    """
    ...

def add_receiver_addr(ip_addr, port, recv_id): # -> None:
    """Add Receiver's IP address to sender's namebook.

    Parameters
    ----------
    ip_addr : str
        receiver's IP address, e,g, '192.168.8.12'
    port : int
        receiver's listening port
    recv_id : int
        receiver's ID
    """
    ...

def sender_connect(): # -> None:
    """Connect to all the receivers.
    """
    ...

def set_rank(rank): # -> None:
    """Set the rank of this process.

    If the process is a client, this is equal to client ID. Otherwise, the process
    is a server and this is equal to server ID.

    Parameters
    ----------
    rank : int
        Rank value
    """
    ...

def get_rank():
    """Get the rank of this process.

    If the process is a client, this is equal to client ID. Otherwise, the process
    is a server and this is equal to server ID.

    Returns
    -------
    int
        Rank value
    """
    ...

def set_machine_id(machine_id): # -> None:
    """Set current machine ID

    Parameters
    ----------
    machine_id : int
        Current machine ID
    """
    ...

def get_machine_id():
    """Get current machine ID

    Returns
    -------
    int
        machine ID
    """
    ...

def set_num_machines(num_machines): # -> None:
    """Set number of machine

    Parameters
    ----------
    num_machines : int
        Number of machine
    """
    ...

def get_num_machines():
    """Get number of machines

    Returns
    -------
    int
        number of machines
    """
    ...

def set_num_server(num_server): # -> None:
    """Set the total number of server.
    """
    ...

def get_num_server():
    """Get the total number of server.
    """
    ...

def set_num_client(num_client): # -> None:
    """Set the total number of client.
    """
    ...

def get_num_client():
    """Get the total number of client.
    """
    ...

def set_num_server_per_machine(num_server): # -> None:
    """Set the total number of server per machine
    """
    ...

def get_num_server_per_machine():
    """Get the total number of server per machine
    """
    ...

def incr_msg_seq():
    """Increment the message sequence number and return the old one.

    Returns
    -------
    long
        Message sequence number
    """
    ...

def get_msg_seq():
    """Get the current message sequence number.

    Returns
    -------
    long
        Message sequence number
    """
    ...

def set_msg_seq(msg_seq): # -> None:
    """Set the current message sequence number.

    Parameters
    ----------
    msg_seq : int
        sequence number of current rpc message.
    """
    ...

def register_service(service_id, req_cls, res_cls=...): # -> None:
    """Register a service to RPC.

    Parameter
    ---------
    service_id : int
        Service ID.
    req_cls : class
        Request class.
    res_cls : class, optional
        Response class. If none, the service has no response.
    """
    ...

def get_service_property(service_id):
    """Get service property.

    Parameters
    ----------
    service_id : int
        Service ID.

    Returns
    -------
    (class, class)
        (Request class, Response class)
    """
    ...

class Request:
    """Base request class"""
    @abc.abstractmethod
    def __getstate__(self): # -> None:
        """Get serializable states.

        Must be inherited by subclasses. For array members, return them as
        individual return values (i.e., do not put them in containers like
        dictionary or list).
        """
        ...
    
    @abc.abstractmethod
    def __setstate__(self, state): # -> None:
        """Construct the request object from serialized states.

        Must be inherited by subclasses.
        """
        ...
    
    @abc.abstractmethod
    def process_request(self, server_state): # -> None:
        """Server-side function to process the request.

        Must be inherited by subclasses.

        Parameters
        ----------
        server_state : ServerState
            Server state data.

        Returns
        -------
        Response
            Response of this request or None if no response.
        """
        ...
    
    @property
    def service_id(self):
        """Get service ID."""
        ...
    


class Response:
    """Base response class"""
    @abc.abstractmethod
    def __getstate__(self): # -> None:
        """Get serializable states.

        Must be inherited by subclasses. For array members, return them as
        individual return values (i.e., do not put them in containers like
        dictionary or list).
        """
        ...
    
    @abc.abstractmethod
    def __setstate__(self, state): # -> None:
        """Construct the response object from serialized states.

        Must be inherited by subclasses.
        """
        ...
    
    @property
    def service_id(self):
        """Get service ID."""
        ...
    


def serialize_to_payload(serializable): # -> tuple[bytearray, list[Unknown]]:
    """Serialize an object to payloads.

    The object must have implemented the __getstate__ function.

    Parameters
    ----------
    serializable : object
        Any serializable object.

    Returns
    -------
    bytearray
        Serialized payload buffer.
    list[Tensor]
        A list of tensor payloads.
    """
    ...

class PlaceHolder:
    """PlaceHolder object for deserialization"""
    ...


_PLACEHOLDER = ...
def deserialize_from_payload(cls, data, tensors):
    """Deserialize and reconstruct the object from payload.

    The object must have implemented the __setstate__ function.

    Parameters
    ----------
    cls : class
        The object class.
    data : bytearray
        Serialized data buffer.
    tensors : list[Tensor]
        A list of tensor payloads.

    Returns
    -------
    object
        De-serialized object of class cls.
    """
    ...

@register_object('rpc.RPCMessage')
class RPCMessage(ObjectBase):
    """Serialized RPC message that can be sent to remote processes.

    This class can be used as argument or return value for C API.

    Attributes
    ----------
    service_id : int
        The remote service ID the message wishes to invoke.
    msg_seq : int
        Sequence number of this message.
    client_id : int
        The client ID.
    server_id : int
        The server ID.
    data : bytearray
        Payload buffer carried by this request.
    tensors : list[tensor]
        Extra payloads in the form of tensors.
    """
    def __init__(self, service_id, msg_seq, client_id, server_id, data, tensors) -> None:
        ...
    
    @property
    def service_id(self):
        """Get service ID."""
        ...
    
    @property
    def msg_seq(self):
        """Get message sequence number."""
        ...
    
    @property
    def client_id(self):
        """Get client ID."""
        ...
    
    @property
    def server_id(self):
        """Get server ID."""
        ...
    
    @property
    def data(self):
        """Get payload buffer."""
        ...
    
    @property
    def tensors(self): # -> list[Unknown]:
        """Get tensor payloads."""
        ...
    


def send_request(target, request): # -> None:
    """Send one request to the target server.

    Serialize the given request object to an :class:`RPCMessage` and send it
    out.

    The operation is non-blocking -- it does not guarantee the payloads have
    reached the target or even have left the sender process. However,
    all the payloads (i.e., data and arrays) can be safely freed after this
    function returns.

    Parameters
    ----------
    target : int
        ID of target server.
    request : Request
        The request to send.

    Raises
    ------
    ConnectionError if there is any problem with the connection.
    """
    ...

def send_request_to_machine(target, request): # -> None:
    """Send one request to the target machine, which will randomly
    select a server node to process this request.

    The operation is non-blocking -- it does not guarantee the payloads have
    reached the target or even have left the sender process. However,
    all the payloads (i.e., data and arrays) can be safely freed after this
    function returns.

    Parameters
    ----------
    target : int
        ID of target machine.
    request : Request
        The request to send.

    Raises
    ------
    ConnectionError if there is any problem with the connection.
    """
    ...

def send_response(target, response): # -> None:
    """Send one response to the target client.

    Serialize the given response object to an :class:`RPCMessage` and send it
    out.

    The operation is non-blocking -- it does not guarantee the payloads have
    reached the target or even have left the sender process. However,
    all the payloads (i.e., data and arrays) can be safely freed after this
    function returns.

    Parameters
    ----------
    target : int
        ID of target client.
    response : Response
        The response to send.

    Raises
    ------
    ConnectionError if there is any problem with the connection.
    """
    ...

def recv_request(timeout=...): # -> tuple[Unknown, Unknown] | None:
    """Receive one request.

    Receive one :class:`RPCMessage` and de-serialize it into a proper Request object.

    The operation is blocking -- it returns when it receives any message
    or it times out.

    Parameters
    ----------
    timeout : int, optional
        The timeout value in milliseconds. If zero, wait indefinitely.

    Returns
    -------
    req : request
        One request received from the target, or None if it times out.
    client_id : int
        Client' ID received from the target.

    Raises
    ------
    ConnectionError if there is any problem with the connection.
    """
    ...

def recv_response(timeout=...): # -> None:
    """Receive one response.

    Receive one :class:`RPCMessage` and de-serialize it into a proper Response object.

    The operation is blocking -- it returns when it receives any message
    or it times out.

    Parameters
    ----------
    timeout : int, optional
        The timeout value in milliseconds. If zero, wait indefinitely.

    Returns
    -------
    res : Response
        One response received from the target, or None if it times out.

    Raises
    ------
    ConnectionError if there is any problem with the connection.
    """
    ...

def remote_call(target_and_requests, timeout=...): # -> list[None]:
    """Invoke registered services on remote servers and collect responses.

    The operation is blocking -- it returns when it receives all responses
    or it times out.

    If the target server state is available locally, it invokes local computation
    to calculate the response.

    Parameters
    ----------
    target_and_requests : list[(int, Request)]
        A list of requests and the server they should be sent to.
    timeout : int, optional
        The timeout value in milliseconds. If zero, wait indefinitely.

    Returns
    -------
    list[Response]
        Responses for each target-request pair. If the request does not have
        response, None is placed.

    Raises
    ------
    ConnectionError if there is any problem with the connection.
    """
    ...

def send_requests_to_machine(target_and_requests): # -> dict[Unknown, Unknown]:
    """ Send requests to the remote machines.

    This operation isn't block. It returns immediately once it sends all requests.

    Parameters
    ----------
    target_and_requests : list[(int, Request)]
        A list of requests and the machine they should be sent to.
    timeout : int, optional
        The timeout value in milliseconds. If zero, wait indefinitely.

    Returns
    -------
    msgseq2pos : dict
        map the message sequence number to its position in the input list.
    """
    ...

def recv_responses(msgseq2pos, timeout=...):
    """ Receive responses

    It returns the responses in the same order as the requests. The order of requests
    are stored in msgseq2pos.

    The operation is blocking -- it returns when it receives all responses
    or it times out.

    Parameters
    ----------
    msgseq2pos : dict
        map the message sequence number to its position in the input list.
    timeout : int, optional
        The timeout value in milliseconds. If zero, wait indefinitely.

    Returns
    -------
    list[Response]
        Responses for each target-request pair. If the request does not have
        response, None is placed.
    """
    ...

def remote_call_to_machine(target_and_requests, timeout=...):
    """Invoke registered services on remote machine
    (which will ramdom select a server to process the request) and collect responses.

    The operation is blocking -- it returns when it receives all responses
    or it times out.

    If the target server state is available locally, it invokes local computation
    to calculate the response.

    Parameters
    ----------
    target_and_requests : list[(int, Request)]
        A list of requests and the machine they should be sent to.
    timeout : int, optional
        The timeout value in milliseconds. If zero, wait indefinitely.

    Returns
    -------
    list[Response]
        Responses for each target-request pair. If the request does not have
        response, None is placed.

    Raises
    ------
    ConnectionError if there is any problem with the connection.
    """
    ...

def send_rpc_message(msg, target): # -> None:
    """Send one message to the target server.

    The operation is non-blocking -- it does not guarantee the payloads have
    reached the target or even have left the sender process. However,
    all the payloads (i.e., data and arrays) can be safely freed after this
    function returns.

    The data buffer in the requst will be copied to internal buffer for actual
    transmission, while no memory copy for tensor payloads (a.k.a. zero-copy).
    The underlying sending threads will hold references to the tensors until
    the contents have been transmitted.

    Parameters
    ----------
    msg : RPCMessage
        The message to send.
    target : int
        target ID

    Raises
    ------
    ConnectionError if there is any problem with the connection.
    """
    ...

def recv_rpc_message(timeout=...):
    """Receive one message.

    The operation is blocking -- it returns when it receives any message
    or it times out.

    Parameters
    ----------
    timeout : int, optional
        The timeout value in milliseconds. If zero, wait indefinitely.

    Returns
    -------
    msg : RPCMessage
        One rpc message received from the target, or None if it times out.

    Raises
    ------
    ConnectionError if there is any problem with the connection.
    """
    ...

def client_barrier(): # -> None:
    """Barrier all client processes"""
    ...

def finalize_server(): # -> None:
    """Finalize resources of current server
    """
    ...

def fast_pull(name, id_tensor, part_id, service_id, machine_count, group_count, machine_id, client_id, local_data, policy):
    """Fast-pull api used by kvstore.

    Parameters
    ----------
    name : str
        data name
    id_tensor : tensor
        data ID
    part_id : tensor
        partition ID of id_tensor
    service_id : int
        service_id of pull request
    machine_count : int
        total number of machine
    group_count : int
        total number of server inside machine
    machine_id : int
        current machine ID
    client_id : int
        current client ID
    local_data : tensor
        local data tensor
    policy : PartitionPolicy
        store the partition information
    """
    ...

def register_sig_handler(): # -> None:
    """Register for handling signal event.
    """
    ...

def copy_data_to_shared_memory(dst, source): # -> None:
    """Copy tensor data to shared-memory tensor
    """
    ...

CLIENT_REGISTER = ...
class ClientRegisterRequest(Request):
    """This request will send client's ip to server.

    Parameters
    ----------
    ip_addr : str
        client's IP address
    """
    def __init__(self, ip_addr) -> None:
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    def process_request(self, server_state): # -> None:
        ...
    


class ClientRegisterResponse(Response):
    """This response will send assigned ID to client.

    Parameters
    ----------
    ID : int
        client's ID
    """
    def __init__(self, client_id) -> None:
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    


SHUT_DOWN_SERVER = ...
class ShutDownRequest(Request):
    """Client send this request to shut-down a server.

    This request has no response.

    Parameters
    ----------
    client_id : int
        client's ID
    """
    def __init__(self, client_id) -> None:
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    def process_request(self, server_state): # -> Literal['exit']:
        ...
    


GET_NUM_CLIENT = ...
class GetNumberClientsResponse(Response):
    """This reponse will send total number of clients.

    Parameters
    ----------
    num_client : int
        total number of clients
    """
    def __init__(self, num_client) -> None:
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    


class GetNumberClientsRequest(Request):
    """Client send this request to get the total number of client.

    Parameters
    ----------
    client_id : int
        client's ID
    """
    def __init__(self, client_id) -> None:
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    def process_request(self, server_state): # -> GetNumberClientsResponse:
        ...
    


CLIENT_BARRIER = ...
class ClientBarrierResponse(Response):
    """Send the barrier confirmation to client

    Parameters
    ----------
    msg : str
        string msg
    """
    def __init__(self, msg=...) -> None:
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    


class ClientBarrierRequest(Request):
    """Send the barrier information to server

    Parameters
    ----------
    msg : str
        string msg
    """
    def __init__(self, msg=...) -> None:
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    def process_request(self, server_state): # -> list[Unknown] | None:
        ...
    


